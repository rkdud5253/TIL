[TOC]

# 1028_완전검색/그리디

- 학습목표

  - 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀호출에 대해 학습
  - 완전검색의 개념을 이해하고 완전 검색을 통한 문제 해결 방법에 대해 학습
  - 조합적 문제에 대한 완전 검색 방법에 대해 이해
    - 순열, 조합, 부분집합 생성하는 알고리즘

  - 탐욕 알고리즘 기법의 개념과 주요특성



## 1. 반복과 재귀

- 반복과 재귀는 유사한 작업을 수행할 수 있음
- 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 루프(for, while구조)

- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합
  - 재귀 함수로 구현

- 반복 구조

  - 초기화
    - 반복되는 명령문을 실행하기 전에 (한번만) 조건 검사에 사용할 변수의 초기값 설정

  - 조건검사
  - 반복할 명령문 실행
  - 업데이트
    - 무한루프가 되지 않게 조건이 거짓이 되게한다



- 반복을 이용한 선택정렬

```python
def SelectionSort(A):
    n = len(A)
    for i in range(0, n-1):
        min = i
        for j in range(i+1, n):
            if A[j] < A[min]:
                min = j
        A[min], A[i] = A[i], A[min]
```



- 재귀적 알고리즘

  - 재귀적 정의는 두 부분으로 나뉨
  - 하나 또는 그 이상의 기본 경우 (basis case or rule)
    - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 (seed) 역할

  - 하나 또는 그 이상의 유도된 경우(inductive case or rule)
    - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법



- 재귀함수(recursive function)

  - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
  - 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현
  - 따라서, 기본부분과 유도부분으로 구성
  - 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해쉬움
    - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낌

  - 함수 호출은 프로그램 메모리 구조에서 스택을 사용함. 따라서 재귀호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생



- 팩토리얼 재귀 함수 (좋은 예는 아님..?)

  - n!에 대한 재귀함수 

    ```python
    def fact(n):
        if n <= 1:   	# Bisis part
            return 1
       	else:        	# Inductive part
            return n * fact(n-1)
    ```

    

- 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
- 재귀는 문제해결을 위한 알고리즘 설계가 간단하고 자연스러움
  
- 추상자료형 (list, tree등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많음
  
- 일반적으로, 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 함
- **입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있음**



- 반복과 재귀의 비교

|               |                  재귀                   |         반복          |
| :------------ | :-------------------------------------: | :-------------------: |
| 종료          | 재귀 함수 호출이 종료되는 베이스 케이스 |  반복문의 종료 조건   |
| 수행시간      |              (상대적) 느림              |         빠름          |
| 메모리 공간   |           (상대적) 많이 사용            |       적게 사용       |
| 소스코드 길이 |                짧고 간결                |         길다          |
| 소스코드 형태 |          선택 구조(if ..else)           | 반복 구조(for, while) |
| 무한 반복시   |             스택 오버플로우             |  CPU를 반복해서 점유  |



- 2^k연산에 대한 재귀와 반복

```python
# 재귀
Power_of_2(k):
    if k == 0:
        return 1
    else:
        return 2 * Power_of_2(k-1)
```

```python
# 반복
Power_of_2(k):
    i = 0
    power = 1
    while i < k:
        power = power * 2
        i = i + 1
    return power
```



### <연습문제1>

- 선택 정렬 함수(SelectionSort)를 재귀적 알고리즘으로 작성해 보시오

```python

```





## 2. 완전검색

<문제: Baby-gin Game>

```python

```



### 고지식한 방법 (brute-force)

- brute-force 는 문제를 해결하기 위한 간단하고 쉬운 접근법
- 대부분의 문제에 적용 가능
- 상대적으로 빠른 시간에 문제해결 가능
- 문제에 포함된 자료의 크기가 작다면 유용
- 학술적 또는 교육적 목적을 위해 알고리즘 효율성을 판단하기 위한 척도로 사용

- Brute-force 탐색

  - 자료들의 리스트에서 키 값을 찾기 위해 첫번째 자료부터 비교하면서 진행

  - 결과 (탐색성공/탐색실패)

    ```python
    SequentialSearch(A[0..n],k):
        A[n] <- k
        i <- 0
        WHILE A[i] != k
        		i++
        IF i < n : RETURN i
      	ELSE : RETURN -1
    ```

    

### 완전검색

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
  - 완전 검색은 입력의 크기를 작게 해서 간편하고 빠르게 답을 구하는 프로그램을 작성

- 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있음
- 검정 등에서 주어진 문제를 풀 때, **우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직**



- 완전 검색을 통한 baby-gin 접근
- 고려할 수 있는 모든 경우의 수 생성하기
  - 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)
  - 예) 입력으로 {2,3,5,7,7}을 받았을 경우, 아래와 같이 순열을 생성할 수 있음

- 해답 테스트하기
  - 앞의 3자리와 뒤의 3자리를 잘라, run 과 triplet 여부를 테스트하고 최종적으로 baby-gin 판단

- 완전 검색
  - 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것
  - 또한, 이들은 전형적으로 순열, 조합, 부분집합과 같은 조합적 문제들과 연관됨
  - 완전 검색은 조합적 문제에 대한 brute-force 방법





-----

## Webex

```python
'''
1~10까지의 합을 구하는 함수를 재귀함수로 구현
값을 리턴하는 형식
'''

def sum(n):
    if n == 1:
        return 1
    return n + sum(n-1)
print(sum(10)) #여기에 결과값이 리턴

>> 55
```

```python
'''
부분집합 : 재귀를 이용해서
'''

def subset(n):
    if n == N:
        for i in range(N):
            if check[i] == 1:
                print(arr[i], end=' ')
        print()
        return
    # 비선택
    check[n] = 0
    subset(n+1)
    # 선택
    check[n] = 1
    subset(n+1)


arr = [1,2,3,4,5]

N = len(arr)
check = [0] * N
subset(0)

>>
5 
4 
4 5 
3 
3 5 
3 4 
3 4 5 
2 
2 5 
2 4 
2 4 5 
2 3 
2 3 5 
2 3 4 
2 3 4 5 
1 
1 5 
1 4 
1 4 5 
1 3 
1 3 5 
1 3 4 
1 3 4 5 
1 2 
1 2 5 
1 2 4 
1 2 4 5 
1 2 3 
1 2 3 5 
1 2 3 4 
1 2 3 4 5 
```

```python
'''
부분집합을 출력하는 코드 작성
비트마스킹을 이용해서
'''

arr = [1,2,3,4,5]
N = len(arr)
for i in range(1 << N):
    for j in range(N):
        if i & (1 << j):
            print(arr[j], end=' ')
    print()
    
>>
1 
2 
1 2 
3 
1 3 
2 3 
1 2 3 
4 
1 4 
2 4 
1 2 4 
3 4 
1 3 4 
2 3 4 
1 2 3 4 
5 
1 5 
2 5 
1 2 5 
3 5 
1 3 5 
2 3 5 
1 2 3 5 
4 5 
1 4 5 
2 4 5 
1 2 4 5 
3 4 5 
1 3 4 5 
2 3 4 5 
1 2 3 4 5 
```

--------





## 3. 조합적 문제

### 1) 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열을 아래와 같이 표현
  
- nPr
  
- 그리고 nPr은 다음과 같은 식 성립
  
- nPr = n x (n-1) x (n-2) x ... x (n-r+1)
  
- nPn = n!이라고 표기하며 Factorial이라 부름
  
- n! = n x (n-1) x (n-2) x ... x 2 x 1
  
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있음
  
- 예) TST(Traveling Salesman Problem)
  
- N개의 요소들에 대해서 n!개의 순열들이 존재
  - 12! = 479,001,600
  - n > 12 인 경우, 시간 복잡도 폭발적으로 높아짐

- 단순하게 순열을 생성하는 방법

  - 예) {1,2,3}을 포함하는 모든 순열을 생성하는 함수

    - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 이용해 아래와 같이 구현 할 수 있다

      ```python
      FOR i1 in 1 -> 3
      	FOR i2 in 1 -> 3
          	IF i2 != i1
              	FOR i3 in 1 -> 3
                  	IF i3 != i1 AND i3 != i2
                      	print(i1,i2,i3)
      ```

      

    - 사전적 순서
      - {1,2,3}, n = 3 인 경우 다음과 같이 생성
      - [1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]

    - 최소 변경을 통한 방법
      - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성
      - [**1** 2 **3**] [**3 2** 1] [2 **3 1**] [**2** 1 **3**] [**3 1** 2] [1 3 2]



#### 재귀 호출을 통한 순열 생성

```python
# arr[] : 데이터가 저장된 배열
# swap(i, j): arr[i] <--교환--> arr[j]
# n:원소의개수, i:선택된원소의수
perm(n,k):
    if k == n:
        print array  # 원하는 작업 수행
    else:
        for i in k -> n-1:
            swap(k, i)
            perm(n, k+1)
            swap(k, i)
```

```python
# n: 숫자를 결정할 인덱스(결정한 개수), k: 순열의 길이
def perm(n, k):
    if n == k:
        print(A)
    else:
        for i in range(n, k):
            A[n], A[i] = A[i], A[n]  # 현재 숫자 유지부터, 오른쪽 끝까지 교환
            perm(n + 1, k)  # 다음자리 결정하러 이동 (n개 결정)
            A[n], A[i] = A[i], A[n]  # 교환 전으로 복구


A = [1, 2, 3]
perm(0, 3)

>>
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 2, 1]
[3, 1, 2]
```

```python
# n:숫자를 결정할 자리인덱스, k:순열의 길이, m:주어진 숫자의 개수
def perm(n, k, m):
    if n == k:
        print(A[0:k])
    else:
        for i in range(n, m):  # n번과 바꿀 위치
            A[n], A[i] = A[i], A[n]
            perm(n+1, k, m)
            A[n], A[i] = A[i], A[n]


A = [1,2,3,4,5]
perm(0, 3, 5)

>>
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 2]
[1, 3, 4]
[1, 3, 5]
[1, 4, 3]
[1, 4, 2]
[1, 4, 5]
[1, 5, 3]
[1, 5, 4]
[1, 5, 2]
[2, 1, 3]
[2, 1, 4]
[2, 1, 5]
[2, 3, 1]
[2, 3, 4]
[2, 3, 5]
[2, 4, 3]
[2, 4, 1]
[2, 4, 5]
[2, 5, 3]
[2, 5, 4]
[2, 5, 1]
[3, 2, 1]
[3, 2, 4]
[3, 2, 5]
[3, 1, 2]
[3, 1, 4]
[3, 1, 5]
[3, 4, 1]
[3, 4, 2]
[3, 4, 5]
[3, 5, 1]
[3, 5, 4]
[3, 5, 2]
[4, 2, 3]
[4, 2, 1]
[4, 2, 5]
[4, 3, 2]
[4, 3, 1]
[4, 3, 5]
[4, 1, 3]
[4, 1, 2]
[4, 1, 5]
[4, 5, 3]
[4, 5, 1]
[4, 5, 2]
[5, 2, 3]
[5, 2, 4]
[5, 2, 1]
[5, 3, 2]
[5, 3, 4]
[5, 3, 1]
[5, 4, 3]
[5, 4, 2]
[5, 4, 1]
[5, 1, 3]
[5, 1, 4]
[5, 1, 2]
```

```python
def perm(n, k, m):
    if n == k:
        print(p)
    else:
        for i in range(m):
            if u[i] == 0:  #A[i]가 사용전이면
                u[i] = 1
                p[n] = A[i]
                perm(n+1, k, m)
                u[i] = 0


A = [1,2,3,4,5]
p = [0]*3
u = [0]*5
perm(0, 3, 5)

>>
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 2]
[1, 3, 4]
[1, 3, 5]
[1, 4, 2]
[1, 4, 3]
[1, 4, 5]
[1, 5, 2]
[1, 5, 3]
[1, 5, 4]
[2, 1, 3]
[2, 1, 4]
[2, 1, 5]
[2, 3, 1]
[2, 3, 4]
[2, 3, 5]
[2, 4, 1]
[2, 4, 3]
[2, 4, 5]
[2, 5, 1]
[2, 5, 3]
[2, 5, 4]
[3, 1, 2]
[3, 1, 4]
[3, 1, 5]
[3, 2, 1]
[3, 2, 4]
[3, 2, 5]
[3, 4, 1]
[3, 4, 2]
[3, 4, 5]
[3, 5, 1]
[3, 5, 2]
[3, 5, 4]
[4, 1, 2]
[4, 1, 3]
[4, 1, 5]
[4, 2, 1]
[4, 2, 3]
[4, 2, 5]
[4, 3, 1]
[4, 3, 2]
[4, 3, 5]
[4, 5, 1]
[4, 5, 2]
[4, 5, 3]
[5, 1, 2]
[5, 1, 3]
[5, 1, 4]
[5, 2, 1]
[5, 2, 3]
[5, 2, 4]
[5, 3, 1]
[5, 3, 2]
[5, 3, 4]
[5, 4, 1]
[5, 4, 2]
[5, 4, 3]
```



#### <연습문제2>

```python

```





### 2) 부분집합

- 집합에 포함된 원소들을 선태하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
- N의 원소를 포함한 집합
  - 자기 자신과 공집합 포함인 모든 부분집합(power set)의 개수는 2^n개
  - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

- 바이너리 카운팅을 통한 사전적 순서

  - 부분집합을 생성하기 위한 가장 자연스러운 방법

  - 바이너리 카운팅은 사전적 순서로 생성하기 위한 가장 간단한 방법

    

#### 바이너리 카운팅

- 원소 수에 해당하는 N개의 비트열을 이용
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미

```python
arr = [3,6,7,1,5,4]
n = len(arr)

for i in range(0, (1<<n)):  # 1<<n : 부분집합의 개수
    for j in range(0, n):  # 원소의 수만큼 비트를 비교
        if i & (1<<j):  # i의 j번째 비트가 1이면 j번째 원소 출력
            print("%d"%arr[j], end='')
        print()
```





### 3) 조합

- 서로 다른 n개의 원소 중 r개를 순서없이 골라낸 것을 조합이라 부름
  - nCr

- 재귀호출을 이용한 조합 생성 알고리즘

```python
# an[]: n개의 원소를 가지고 있는 배열
# tr[]: r개의 크기의 배열, 조합이 임시 저장될 배열

comb(n, r):
    if (r==0): print_arr()
    elif (n<r): return
    else:
        tr[r-1] = an[n-1]
        comb(n-1, r-1)
        comb(n-1, r)
```

```python
# n:c[n]조합의 인덱스, s:선택구간의 시작, N:주어진 개수, r:고를 개수
def f(n, s, N, r):
    if n == r:
        print(c)
    else:
        for i in range(s, N-r+n+1):
            c[n] = i
            f(n+1, i+1, N, r)


N = 10
r = 3
c = [0] * 3
f(0, 0, N, r)

>>
[0, 1, 2]
[0, 1, 3]
[0, 1, 4]
[0, 1, 5]
[0, 1, 6]
[0, 1, 7]
[0, 1, 8]
[0, 1, 9]
[0, 2, 3]
[0, 2, 4]
[0, 2, 5]
[0, 2, 6]
[0, 2, 7]
[0, 2, 8]
[0, 2, 9]
[0, 3, 4]
[0, 3, 5]
[0, 3, 6]
[0, 3, 7]
[0, 3, 8]
[0, 3, 9]
[0, 4, 5]
[0, 4, 6]
[0, 4, 7]
[0, 4, 8]
[0, 4, 9]
[0, 5, 6]
[0, 5, 7]
[0, 5, 8]
[0, 5, 9]
[0, 6, 7]
[0, 6, 8]
[0, 6, 9]
[0, 7, 8]
[0, 7, 9]
[0, 8, 9]
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 2, 6]
[1, 2, 7]
[1, 2, 8]
[1, 2, 9]
[1, 3, 4]
[1, 3, 5]
[1, 3, 6]
[1, 3, 7]
[1, 3, 8]
[1, 3, 9]
[1, 4, 5]
[1, 4, 6]
[1, 4, 7]
[1, 4, 8]
[1, 4, 9]
[1, 5, 6]
[1, 5, 7]
[1, 5, 8]
[1, 5, 9]
[1, 6, 7]
[1, 6, 8]
[1, 6, 9]
[1, 7, 8]
[1, 7, 9]
[1, 8, 9]
[2, 3, 4]
[2, 3, 5]
[2, 3, 6]
[2, 3, 7]
[2, 3, 8]
[2, 3, 9]
[2, 4, 5]
[2, 4, 6]
[2, 4, 7]
[2, 4, 8]
[2, 4, 9]
[2, 5, 6]
[2, 5, 7]
[2, 5, 8]
[2, 5, 9]
[2, 6, 7]
[2, 6, 8]
[2, 6, 9]
[2, 7, 8]
[2, 7, 9]
[2, 8, 9]
[3, 4, 5]
[3, 4, 6]
[3, 4, 7]
[3, 4, 8]
[3, 4, 9]
[3, 5, 6]
[3, 5, 7]
[3, 5, 8]
[3, 5, 9]
[3, 6, 7]
[3, 6, 8]
[3, 6, 9]
[3, 7, 8]
[3, 7, 9]
[3, 8, 9]
[4, 5, 6]
[4, 5, 7]
[4, 5, 8]
[4, 5, 9]
[4, 6, 7]
[4, 6, 8]
[4, 6, 9]
[4, 7, 8]
[4, 7, 9]
[4, 8, 9]
[5, 6, 7]
[5, 6, 8]
[5, 6, 9]
[5, 7, 8]
[5, 7, 9]
[5, 8, 9]
[6, 7, 8]
[6, 7, 9]
[6, 8, 9]
[7, 8, 9]
```



## Webex

```python
# 순열

'''
n개에서 n을 다 뽑은 순열 함수 만들기
1,2,3
1,3,2
...
...
'''
# k: 선택한 원소가 들어갈 자리 (sel 배열에 넣을 것)
def perm(k):
    if k == n:
        print(sel)
        return
    for i in range(n):
        if visited[i] == 0:
            sel[k] = arr[i]
            visited[i] = 1
            perm(k+1)
            visited[i] = 0


arr = [1,2,3]   # 순열을 생성한 배열
n = len(arr)  # 순열의 길이
sel = [0] * n  # 순열을 저장하기 위한 배열
visited = [0] * n  # 특정 원소를 이미 사용했는지 저장하기 위한 배열
perm(0)    # 0번째부터 시작

>>
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

```python
# 순열2

'''
nPr : n개에서 r개를 선택한 순열 함수 만들기

3P2
출력결과
1,2
1,3
2,3
2,1
3,1
3,2
'''

def perm(k):   # 매개변수 뭐가 필요하지?  k: sel의 어느자리 서택할지
    if k == r:     # 다 선택하면
        print(sel)
        return
    for i in range(n):
        if visited[i] == 0:
            sel[k] = arr[i]
            visited[i] = 1
            perm(k+1)
            visited[i] = 0



arr = [1,2,3]   # 순열을 생성한 배열
n = len(arr)  # 순열의 길이
# 뭐가 필요한지?
r = 2
sel = [0] * r   # 선택한 원소를 담기 위한 배열 (길이:r)
visited = [0] * n   # 어떤 원소가 이ㅣ 사용되었는지 표시 (길이:n)
perm(0)

>>
[1, 2]
[1, 3]
[2, 1]
[2, 3]
[3, 1]
[3, 2]
```

